/**
 * Core Philosophy: This ruleset implements a Role-Based Access Control (RBAC) model.
 * A dedicated `/roles_admin` collection is used to grant administrative privileges to specific users.
 * The default security posture is restrictive: data is private unless explicitly made public.
 *
 * Data Structure:
 * - /projects/{projectId}: Publicly readable data about real estate projects.
 * - /contact_messages/{contactMessageId}: Write-only for the public, readable only by admins.
 * - /roles_admin/{adminId}: A list of admin UIDs, used as a lookup for authorization.
 *
 * Key Security Decisions:
 * - Admin Access: A user is considered an admin if a document with their UID exists in the `/roles_admin` collection. This is checked using an `exists()` call.
 * - Public vs. Admin Content: Projects are public for reading but require admin rights for writing. Contact messages can be created by anyone but can only be read or managed by admins.
 * - Privilege Escalation Prevention: The `/roles_admin` collection itself is locked down, requiring a user to already be an admin to view, add, or remove other admins.
 * - Denormalization for Authorization: This ruleset does not require denormalization as it uses a centralized RBAC lookup collection (`/roles_admin`), which is a standard and secure pattern for managing global roles.
 * - Structural Segregation: The use of separate top-level collections for public data (`/projects`) and admin-gated data (`/contact_messages`) ensures that list queries are both secure and performant without needing complex server-side filtering.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // ----------------------------------------------------------------------
    // Helper Functions
    // ----------------------------------------------------------------------

    /**
     * Checks if a user is authenticated.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * Checks if the authenticated user has an admin role.
     * Admin status is determined by the existence of a document in the
     * `/roles_admin` collection with the user's UID as the document ID.
     */
    function isAdmin() {
      return isSignedIn() && exists(/databases/$(database)/documents/roles_admin/$(request.auth.uid));
    }

    /**
     * Checks if a document exists. Used to protect against modifying or deleting
     * non-existent documents.
     */
    function isExistingDoc() {
      return resource != null;
    }

    /**
     * On create, validates that a document's internal 'id' field matches its document ID.
     * This enforces relational integrity from the client.
     */
    function isConsistentIdOnCreate(docId) {
      return request.resource.data.id == docId;
    }

    /**
     * On update, ensures the document's internal 'id' field cannot be changed.
     * This protects the primary relational key of the document.
     */
    function isIdImmutable() {
      return request.resource.data.id == resource.data.id;
    }


    // ----------------------------------------------------------------------
    // Collection Rules
    // ----------------------------------------------------------------------

    /**
     * @description Controls access to real estate project data. All users (including unauthenticated ones) can read project details, but only admins can create, update, or delete them.
     * @path /projects/{projectId}
     * @allow (get) An anonymous user reads a single project document.
     * @allow (create) An admin user (auth.uid exists in /roles_admin) creates a new project.
     * @deny (update) A non-admin authenticated user tries to update a project's title.
     * @principle Implements public-read access for general content and Role-Based writes for content management.
     */
    match /projects/{projectId} {
      allow get, list: if true;
      allow create: if isAdmin() && isConsistentIdOnCreate(projectId);
      allow update: if isAdmin() && isExistingDoc() && isIdImmutable();
      allow delete: if isAdmin() && isExistingDoc();
    }

    /**
     * @description Manages contact form submissions. Any user (including anonymous) can create a message, but only admins can read, update, or delete messages.
     * @path /contact_messages/{contactMessageId}
     * @allow (create) An anonymous user submits a message through the contact form.
     * @allow (get) An admin user reads a specific contact message.
     * @deny (list) A non-admin authenticated user tries to list all submitted messages.
     * @principle Enforces a "write-only" dropbox pattern for the public, with privileged read access for admins.
     */
    match /contact_messages/{contactMessageId} {
      allow get, list: if isAdmin();
      allow create: if isConsistentIdOnCreate(contactMessageId);
      allow update: if isAdmin() && isExistingDoc() && isIdImmutable();
      allow delete: if isAdmin() && isExistingDoc();
    }

    /**
     * @description Secures the collection that defines administrator roles. Only existing admins can read or write to this collection, preventing unauthorized users from escalating their privileges.
     * @path /roles_admin/{adminId}
     * @allow (create) An existing admin adds a new document to make another user an admin.
     * @allow (get) An existing admin reads a document to verify another user's admin status.
     * @deny (create) A non-admin authenticated user tries to create a document with their own UID to make themselves an admin.
     * @principle Prevents privilege escalation by ensuring only admins can manage admin roles.
     */
    match /roles_admin/{adminId} {
      allow get, list: if isAdmin();
      allow create: if isAdmin() && isConsistentIdOnCreate(adminId);
      allow update: if isAdmin() && isExistingDoc() && isIdImmutable();
      allow delete: if isAdmin() && isExistingDoc();
    }
  }
}